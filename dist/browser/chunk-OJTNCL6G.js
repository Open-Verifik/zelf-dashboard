import{aa as p}from"./chunk-3HE7R7QB.js";import{g as i}from"./chunk-TSRGIXR5.js";var h=(()=>{class l{constructor(){this.STORAGE_KEY="zelf_passkeys"}isSupported(){return i(this,null,function*(){return!!window.PublicKeyCredential})}register(t){return i(this,null,function*(){try{let e=crypto.getRandomValues(new Uint8Array(32)),r=crypto.getRandomValues(new Uint8Array(16)),n=crypto.getRandomValues(new Uint8Array(32)),a={publicKey:{challenge:e,rp:{name:"Zelf Dashboard",id:window.location.hostname},user:{id:r,name:t,displayName:t},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],timeout:6e4,authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required",residentKey:"required"},extensions:{prf:{eval:{first:n}}}}},s=yield navigator.credentials.create(a);if(!s)return null;let o=s.getClientExtensionResults(),u;if(o.prf&&o.prf.results&&o.prf.results.first)u=new Uint8Array(o.prf.results.first);else{console.warn("PRF extension not supported or enabled. falling back to HKDF using Credential ID.");let f=new TextEncoder().encode(s.id);u=new Uint8Array(32);for(let y=0;y<32;y++)u[y]=f[y%f.length]^n[y%n.length]}let d=yield this.importKey(u);return{credentialId:s.id,key:d,salt:n}}catch(e){return console.error("Error creating passkey:",e),null}})}authenticate(t,e){return i(this,null,function*(){try{let n={publicKey:{challenge:crypto.getRandomValues(new Uint8Array(32)),timeout:6e4,userVerification:"required",allowCredentials:[{id:this.base64UrlToBuffer(t),type:"public-key"}],extensions:{prf:{eval:{first:e}}}}},a=yield navigator.credentials.get(n);if(!a)return null;let s=a.getClientExtensionResults(),o;if(s.prf&&s.prf.results&&s.prf.results.first)o=new Uint8Array(s.prf.results.first);else{console.warn("PRF extension not supported in Auth. Using fallback derivation.");let d=new TextEncoder().encode(a.id);o=new Uint8Array(32);for(let c=0;c<32;c++)o[c]=d[c%d.length]^e[c%e.length]}return yield this.importKey(o)}catch(r){return console.error("Error authenticating passkey:",r),null}})}encryptPassword(t,e){return i(this,null,function*(){let r=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder().encode(t),a=yield crypto.subtle.encrypt({name:"AES-GCM",iv:r},e,n);return{ciphertext:this.bufferToBase64(a),iv:this.bufferToBase64(r)}})}decryptPassword(t,e,r){return i(this,null,function*(){let n=this.base64ToBuffer(e),a=this.base64ToBuffer(t),s=yield crypto.subtle.decrypt({name:"AES-GCM",iv:n},r,a);return new TextDecoder().decode(s)})}savePasskeyMetadata(t,e){let r=this.getStore();r[t]=e,localStorage.setItem(this.STORAGE_KEY,JSON.stringify(r))}getPasskeyMetadata(t){return this.getStore()[t]||null}getStore(){try{return JSON.parse(localStorage.getItem(this.STORAGE_KEY)||"{}")}catch{return{}}}importKey(t){return i(this,null,function*(){return yield crypto.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["encrypt","decrypt"])})}bufferToBase64(t){let e=new Uint8Array(t),r="";for(let n=0;n<e.byteLength;n++)r+=String.fromCharCode(e[n]);return btoa(r)}base64ToBuffer(t){let e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r}base64UrlToBuffer(t){let e=t.replace(/-/g,"+").replace(/_/g,"/"),r=e.length%4,n=r?e+"=".repeat(4-r):e;return this.base64ToBuffer(n)}static{this.\u0275fac=function(e){return new(e||l)}}static{this.\u0275prov=p({token:l,factory:l.\u0275fac,providedIn:"root"})}}return l})();export{h as a};
